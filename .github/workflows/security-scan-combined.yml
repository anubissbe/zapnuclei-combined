name: Security Scan (ZAP + Nuclei)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read
  security-events: write

jobs:
  build-and-scan:
    name: Build and Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Build and start the application
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Start application in background
        run: npm start &
        env:
          PORT: 3000

      - name: Wait for application to be ready
        run: |
          echo "Waiting for application to start..."
          timeout 60 bash -c 'until curl -sf http://localhost:3000/health > /dev/null 2>&1; do sleep 2; done'
          echo "Application is ready!"

      - name: Get runner IP for Docker access
        id: ip
        run: echo "address=$(hostname -I | awk '{print $1}')" >> $GITHUB_OUTPUT

      # ZAP Scan - outputs SARIF format
      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.14.0
        with:
          target: 'http://${{ steps.ip.outputs.address }}:3000'
          cmd_options: '-a'
          fail_action: false
          allow_issue_writing: false
        continue-on-error: true

      # Convert ZAP JSON to SARIF if needed
      - name: Check ZAP outputs
        run: |
          echo "=== Checking for ZAP output files ==="
          ls -la *.json *.sarif *.html *.md 2>/dev/null || echo "No report files found in root"
          ls -la report* 2>/dev/null || echo "No report files found"
          # ZAP baseline creates report_json.json, we need to check for sarif
          if [ -f "report_json.json" ]; then
            echo "Found report_json.json"
            cat report_json.json | head -50
          fi
        continue-on-error: true

      # Convert ZAP JSON to SARIF format
      - name: Convert ZAP JSON to SARIF
        run: |
          if [ -f "report_json.json" ]; then
            echo "Converting ZAP JSON to SARIF format..."
            python3 << 'EOF'
          import json

          with open('report_json.json', 'r') as f:
              zap = json.load(f)

          sarif = {
              "version": "2.1.0",
              "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
              "runs": [{
                  "tool": {
                      "driver": {
                          "name": "OWASP ZAP",
                          "version": zap.get("@version", "unknown"),
                          "informationUri": "https://www.zaproxy.org/",
                          "rules": []
                      }
                  },
                  "results": []
              }]
          }

          rules = {}
          results = []

          risk_to_level = {"0": "note", "1": "note", "2": "warning", "3": "error"}
          risk_to_severity = {"0": "1", "1": "3", "2": "6", "3": "9"}

          for site in zap.get("site", []):
              for alert in site.get("alerts", []):
                  rule_id = alert.get("pluginid", "unknown")
                  
                  if rule_id not in rules:
                      rules[rule_id] = {
                          "id": rule_id,
                          "name": alert.get("name", "Unknown"),
                          "shortDescription": {"text": alert.get("name", "Unknown")},
                          "fullDescription": {"text": alert.get("desc", "")[:1000]},
                          "helpUri": alert.get("reference", "").split("\n")[0] if alert.get("reference") else "",
                          "properties": {
                              "security-severity": risk_to_severity.get(alert.get("riskcode", "1"), "5")
                          }
                      }
                  
                  for instance in alert.get("instances", []):
                      uri = instance.get("uri", "")
                      # Convert URL to file-like path
                      from urllib.parse import urlparse
                      parsed = urlparse(uri)
                      path = parsed.path if parsed.path and parsed.path != '/' else '/index'
                      
                      results.append({
                          "ruleId": rule_id,
                          "level": risk_to_level.get(alert.get("riskcode", "1"), "warning"),
                          "message": {
                              "text": f"{alert.get('name', 'Unknown')}: {alert.get('solution', '')[:500]}"
                          },
                          "locations": [{
                              "physicalLocation": {
                                  "artifactLocation": {
                                      "uri": f"web{path}",
                                      "uriBaseId": "%SRCROOT%"
                                  },
                                  "region": {"startLine": 1, "startColumn": 1}
                              }
                          }]
                      })

          sarif["runs"][0]["tool"]["driver"]["rules"] = list(rules.values())
          sarif["runs"][0]["results"] = results

          with open('zap-results.sarif', 'w') as f:
              json.dump(sarif, f, indent=2)
          print(f"Created zap-results.sarif with {len(results)} findings")
          EOF
          fi
        continue-on-error: true

      - name: Upload ZAP SARIF Report
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'zap-results.sarif'
          category: 'zap-scan'
        if: hashFiles('zap-results.sarif') != ''
        continue-on-error: true

      # Nuclei Scan - outputs SARIF format
      - name: Nuclei Scan
        uses: projectdiscovery/nuclei-action@v2.0.1
        with:
          target: 'http://${{ steps.ip.outputs.address }}:3000'
          sarif-export: 'nuclei-results.sarif'
          severity: 'critical,high,medium,low,info'
          rate-limit: 150
          github-token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Check Nuclei outputs
        run: |
          echo "=== Checking for Nuclei output files ==="
          ls -la *.sarif 2>/dev/null || echo "No SARIF files found"
          ls -la nuclei* 2>/dev/null || echo "No nuclei files found"
          if [ -f "nuclei-results.sarif" ]; then
            echo "Found nuclei-results.sarif"
            cat nuclei-results.sarif | head -50
          fi
        continue-on-error: true

      # Fix SARIF files for GitHub Code Scanning
      # GitHub requires URIs to be relative paths to actual files in the repo
      - name: Fix SARIF files for GitHub
        run: |
          # Create a completely new SARIF file from Nuclei results
          # Map findings to server.js since that's where the vulnerable endpoints are defined
          if [ -f "nuclei-results.sarif" ]; then
            echo "Creating GitHub-compatible SARIF from Nuclei results..."
            python3 << 'EOF'
          import json
          from urllib.parse import urlparse

          with open('nuclei-results.sarif', 'r') as f:
              original = json.load(f)

          # Build a new SARIF from scratch following GitHub's requirements exactly
          new_sarif = {
              "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
              "version": "2.1.0",
              "runs": []
          }

          for run in original.get('runs', []):
              tool = run.get('tool', {}).get('driver', {})
              
              new_run = {
                  "tool": {
                      "driver": {
                          "name": tool.get('name', 'Nuclei'),
                          "semanticVersion": tool.get('semanticVersion', '3.0.0'),
                          "rules": []
                      }
                  },
                  "results": []
              }
              
              # Process rules - must have shortDescription and fullDescription
              rules_map = {}
              for rule in tool.get('rules', []):
                  rule_id = rule.get('id', 'unknown')
                  new_rule = {
                      "id": rule_id,
                      "name": rule.get('name', rule_id),
                      "shortDescription": {"text": rule.get('shortDescription', {}).get('text', rule_id)[:1024]},
                      "fullDescription": {"text": rule.get('fullDescription', {}).get('text', 'Security finding')[:1024]},
                      "help": {"text": "Security vulnerability detected by Nuclei scanner.", "markdown": "**Security vulnerability** detected by Nuclei scanner."},
                      "properties": {
                          "security-severity": str(rule.get('properties', {}).get('security-severity', '5.0'))
                      }
                  }
                  rules_map[rule_id] = len(new_run["tool"]["driver"]["rules"])
                  new_run["tool"]["driver"]["rules"].append(new_rule)
              
              # Process results - URI must be a real file in the repo
              for result in run.get('results', []):
                  rule_id = result.get('ruleId', 'unknown')
                  message = result.get('message', {}).get('text', 'Security finding')
                  
                  # Map to server.js since that's where endpoints are defined
                  new_result = {
                      "ruleId": rule_id,
                      "ruleIndex": rules_map.get(rule_id, 0),
                      "level": "warning",
                      "message": {"text": message[:1024]},
                      "locations": [
                          {
                              "physicalLocation": {
                                  "artifactLocation": {
                                      "uri": "server.js"
                                  },
                                  "region": {
                                      "startLine": 1,
                                      "startColumn": 1,
                                      "endColumn": 2
                                  }
                              }
                          }
                      ],
                      "partialFingerprints": {
                          "primaryLocationLineHash": f"{hash(rule_id + message) & 0xFFFFFFFF:08x}:1"
                      }
                  }
                  new_run["results"].append(new_result)
              
              new_sarif["runs"].append(new_run)

          with open('nuclei-results-fixed.sarif', 'w') as f:
              json.dump(new_sarif, f, indent=2)
          
          print(f"Created nuclei-results-fixed.sarif with {len(new_sarif['runs'][0]['results'])} findings")
          print("\n=== Sample result ===")
          print(json.dumps(new_sarif['runs'][0]['results'][0], indent=2))
          EOF
          fi
        continue-on-error: true

      - name: Upload Nuclei SARIF Report
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'nuclei-results-fixed.sarif'
          category: 'nuclei-scan'
        if: hashFiles('nuclei-results-fixed.sarif') != ''
        continue-on-error: true

      # Save reports as artifacts
      - name: Upload Reports as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-reports
          path: |
            *.sarif
            *.json
            *.html
            *.md
          retention-days: 30
        if: always()
